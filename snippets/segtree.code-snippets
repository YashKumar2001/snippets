{
	"segtree": {
		"prefix": "segtree",
		"body": [
		  "struct item",
		  "{",
		  "    ll v;",
		  "};",
		  "struct segtree",
		  "{",
		  "    ll size;",
		  "    vector<item> values;",
		  "    item neutral={0};",
		  "    item merge(item a,item b)",
		  "    {",
		  "        return {a.v+b.v};",
		  "    }",
		  "    item single(ll v)",
		  "    {",
		  "        return {v};",
		  "    }",
		  "    void init(ll n)",
		  "    {",
		  "        size=1;",
		  "        while(size<n) size*=2;",
		  "        values.resize(2*size,neutral);",
		  "    }",
		  "    void build(vector<ll>&a,ll x,ll lx,ll rx)",
		  "    {",
		  "        if(rx-lx==1)",
		  "        {",
		  "            if(lx<a.size()) values[x]=single(a[lx]);",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        build(a,2*x+1,lx,m);",
		  "        build(a,2*x+2,m,rx);",
		  "        values[x]=merge(values[2*x+1],values[2*x+2]);",
		  "    }",
		  "    void build(vector<ll> &a)",
		  "    {",
		  "        build(a,0,0,size);",
		  "    }",
		  "    ",
		  "    void set(ll i,ll v,ll x,ll lx,ll rx)",
		  "    {",
		  "        if(rx-lx==1) ",
		  "        {",
		  "            values[x]=single(v);",
		  "            return;",
		  "        }",
		  "        ll m=(lx+rx)/2;",
		  "        if(i<m) set(i,v,2*x+1,lx,m);",
		  "        else set(i,v,2*x+2,m,rx);",
		  "        values[x]=merge(values[2*x+1],values[2*x+2]);",
		  "    }",
		  "    void set(ll i,ll v)",
		  "    {",
		  "        set(i,v,0,0,size);",
		  "    }",
		  " ",
		  "    item query(ll l,ll r,ll x,ll lx,ll rx)",
		  "    {",
		  "        if(lx>=r || l>=rx) return neutral;",
		  "        if(lx>=l && rx<=r) return values[x];",
		  "        ll m=(lx+rx)/2;",
		  "        item s1=query(l,r,x*2+1,lx,m);",
		  "        item s2=query(l,r,x*2+2,m,rx);",
		  "        return merge(s1,s2);",
		  "    }",
		  "    item query(ll l,ll r)",
		  "    {",
		  "        return query(l,r,0,0,size);",
		  "    }",
		  "};"
		],
		"description": "segtree"
	  }
}